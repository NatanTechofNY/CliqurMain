// // if(Meteor.isClient){
// // 	// https://cdnjs.cloudflare.com/ajax/libs/list.js/1.2.0/list.min.js
// // 	!function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){!function(c,d){"use strict";var e=c.document,f=a("./src/utils/get-by-class"),g=a("./src/utils/extend"),h=a("./src/utils/index-of"),i=a("./src/utils/events"),j=a("./src/utils/to-string"),k=a("./src/utils/natural-sort"),l=a("./src/utils/classes"),m=a("./src/utils/get-attribute"),n=a("./src/utils/to-array"),o=function(b,c,p){var q,r=this,s=a("./src/item")(r),t=a("./src/add-async")(r);q={start:function(){r.listClass="list",r.searchClass="search",r.sortClass="sort",r.page=1e4,r.i=1,r.items=[],r.visibleItems=[],r.matchingItems=[],r.searched=!1,r.filtered=!1,r.searchColumns=d,r.handlers={updated:[]},r.plugins={},r.valueNames=[],r.utils={getByClass:f,extend:g,indexOf:h,events:i,toString:j,naturalSort:k,classes:l,getAttribute:m,toArray:n},r.utils.extend(r,c),r.listContainer="string"==typeof b?e.getElementById(b):b,r.listContainer&&(r.list=f(r.listContainer,r.listClass,!0),r.parse=a("./src/parse")(r),r.templater=a("./src/templater")(r),r.search=a("./src/search")(r),r.filter=a("./src/filter")(r),r.sort=a("./src/sort")(r),this.handlers(),this.items(),r.update(),this.plugins())},handlers:function(){for(var a in r.handlers)r[a]&&r.on(a,r[a])},items:function(){r.parse(r.list),p!==d&&r.add(p)},plugins:function(){for(var a=0;a<r.plugins.length;a++){var b=r.plugins[a];r[b.name]=b,b.init(r,o)}}},this.reIndex=function(){r.items=[],r.visibleItems=[],r.matchingItems=[],r.searched=!1,r.filtered=!1,r.parse(r.list)},this.toJSON=function(){for(var a=[],b=0,c=r.items.length;c>b;b++)a.push(r.items[b].values());return a},this.add=function(a,b){if(0!==a.length){if(b)return void t(a,b);var c=[],e=!1;a[0]===d&&(a=[a]);for(var f=0,g=a.length;g>f;f++){var h=null;e=r.items.length>r.page?!0:!1,h=new s(a[f],d,e),r.items.push(h),c.push(h)}return r.update(),c}},this.show=function(a,b){return this.i=a,this.page=b,r.update(),r},this.remove=function(a,b,c){for(var d=0,e=0,f=r.items.length;f>e;e++)r.items[e].values()[a]==b&&(r.templater.remove(r.items[e],c),r.items.splice(e,1),f--,e--,d++);return r.update(),d},this.get=function(a,b){for(var c=[],d=0,e=r.items.length;e>d;d++){var f=r.items[d];f.values()[a]==b&&c.push(f)}return c},this.size=function(){return r.items.length},this.clear=function(){return r.templater.clear(),r.items=[],r},this.on=function(a,b){return r.handlers[a].push(b),r},this.off=function(a,b){var c=r.handlers[a],d=h(c,b);return d>-1&&c.splice(d,1),r},this.trigger=function(a){for(var b=r.handlers[a].length;b--;)r.handlers[a][b](r);return r},this.reset={filter:function(){for(var a=r.items,b=a.length;b--;)a[b].filtered=!1;return r},search:function(){for(var a=r.items,b=a.length;b--;)a[b].found=!1;return r}},this.update=function(){var a=r.items,b=a.length;r.visibleItems=[],r.matchingItems=[],r.templater.clear();for(var c=0;b>c;c++)a[c].matching()&&r.matchingItems.length+1>=r.i&&r.visibleItems.length<r.page?(a[c].show(),r.visibleItems.push(a[c]),r.matchingItems.push(a[c])):a[c].matching()?(r.matchingItems.push(a[c]),a[c].hide()):a[c].hide();return r.trigger("updated"),r},q.start()};"function"==typeof define&&define.amd&&define(function(){return o}),b.exports=o,c.List=o}(window)},{"./src/add-async":2,"./src/filter":3,"./src/item":4,"./src/parse":5,"./src/search":6,"./src/sort":7,"./src/templater":8,"./src/utils/classes":9,"./src/utils/events":10,"./src/utils/extend":11,"./src/utils/get-attribute":12,"./src/utils/get-by-class":13,"./src/utils/index-of":14,"./src/utils/natural-sort":15,"./src/utils/to-array":16,"./src/utils/to-string":17}],2:[function(a,b,c){b.exports=function(a){var b=function(c,d,e){var f=c.splice(0,50);e=e||[],e=e.concat(a.add(f)),c.length>0?setTimeout(function(){b(c,d,e)},1):(a.update(),d(e))};return b}},{}],3:[function(a,b,c){b.exports=function(a){return a.handlers.filterStart=a.handlers.filterStart||[],a.handlers.filterComplete=a.handlers.filterComplete||[],function(b){if(a.trigger("filterStart"),a.i=1,a.reset.filter(),void 0===b)a.filtered=!1;else{a.filtered=!0;for(var c=a.items,d=0,e=c.length;e>d;d++){var f=c[d];b(f)?f.filtered=!0:f.filtered=!1}}return a.update(),a.trigger("filterComplete"),a.visibleItems}}},{}],4:[function(a,b,c){b.exports=function(a){return function(b,c,d){var e=this;this._values={},this.found=!1,this.filtered=!1;var f=function(b,c,d){if(void 0===c)d?e.values(b,d):e.values(b);else{e.elm=c;var f=a.templater.get(e,b);e.values(f)}};this.values=function(b,c){if(void 0===b)return e._values;for(var d in b)e._values[d]=b[d];c!==!0&&a.templater.set(e,e.values())},this.show=function(){a.templater.show(e)},this.hide=function(){a.templater.hide(e)},this.matching=function(){return a.filtered&&a.searched&&e.found&&e.filtered||a.filtered&&!a.searched&&e.filtered||!a.filtered&&a.searched&&e.found||!a.filtered&&!a.searched},this.visible=function(){return e.elm&&e.elm.parentNode==a.list?!0:!1},f(b,c,d)}}},{}],5:[function(a,b,c){b.exports=function(b){var c=a("./item")(b),d=function(a){for(var b=a.childNodes,c=[],d=0,e=b.length;e>d;d++)void 0===b[d].data&&c.push(b[d]);return c},e=function(a,d){for(var e=0,f=a.length;f>e;e++)b.items.push(new c(d,a[e]))},f=function(a,c){var d=a.splice(0,50);e(d,c),a.length>0?setTimeout(function(){f(a,c)},1):(b.update(),b.trigger("parseComplete"))};return b.handlers.parseComplete=b.handlers.parseComplete||[],function(){var a=d(b.list),c=b.valueNames;b.indexAsync?f(a,c):e(a,c)}}},{"./item":4}],6:[function(a,b,c){b.exports=function(a){var b,c,d,e,f={resetList:function(){a.i=1,a.templater.clear(),e=void 0},setOptions:function(a){2==a.length&&a[1]instanceof Array?c=a[1]:2==a.length&&"function"==typeof a[1]?e=a[1]:3==a.length&&(c=a[1],e=a[2])},setColumns:function(){0!==a.items.length&&void 0===c&&(c=void 0===a.searchColumns?f.toArray(a.items[0].values()):a.searchColumns)},setSearchString:function(b){b=a.utils.toString(b).toLowerCase(),b=b.replace(/[-[\]{}()*+?.,\\^$|#]/g,"\\$&"),d=b},toArray:function(a){var b=[];for(var c in a)b.push(c);return b}},g={list:function(){for(var b=0,c=a.items.length;c>b;b++)g.item(a.items[b])},item:function(a){a.found=!1;for(var b=0,d=c.length;d>b;b++)if(g.values(a.values(),c[b]))return void(a.found=!0)},values:function(c,e){return c.hasOwnProperty(e)&&(b=a.utils.toString(c[e]).toLowerCase(),""!==d&&b.search(d)>-1)?!0:!1},reset:function(){a.reset.search(),a.searched=!1}},h=function(b){return a.trigger("searchStart"),f.resetList(),f.setSearchString(b),f.setOptions(arguments),f.setColumns(),""===d?g.reset():(a.searched=!0,e?e(d,c):g.list()),a.update(),a.trigger("searchComplete"),a.visibleItems};return a.handlers.searchStart=a.handlers.searchStart||[],a.handlers.searchComplete=a.handlers.searchComplete||[],a.utils.events.bind(a.utils.getByClass(a.listContainer,a.searchClass),"keyup",function(b){var c=b.target||b.srcElement,d=""===c.value&&!a.searched;d||h(c.value)}),a.utils.events.bind(a.utils.getByClass(a.listContainer,a.searchClass),"input",function(a){var b=a.target||a.srcElement;""===b.value&&h("")}),h}},{}],7:[function(a,b,c){b.exports=function(a){a.sortFunction=a.sortFunction||function(b,c,d){return d.desc="desc"==d.order?!0:!1,a.utils.naturalSort(b.values()[d.valueName],c.values()[d.valueName],d)};var b={els:void 0,clear:function(){for(var c=0,d=b.els.length;d>c;c++)a.utils.classes(b.els[c]).remove("asc"),a.utils.classes(b.els[c]).remove("desc")},getOrder:function(b){var c=a.utils.getAttribute(b,"data-order");return"asc"==c||"desc"==c?c:a.utils.classes(b).has("desc")?"asc":a.utils.classes(b).has("asc")?"desc":"asc"},getInSensitive:function(b,c){var d=a.utils.getAttribute(b,"data-insensitive");"false"===d?c.insensitive=!1:c.insensitive=!0},setOrder:function(c){for(var d=0,e=b.els.length;e>d;d++){var f=b.els[d];if(a.utils.getAttribute(f,"data-sort")===c.valueName){var g=a.utils.getAttribute(f,"data-order");"asc"==g||"desc"==g?g==c.order&&a.utils.classes(f).add(c.order):a.utils.classes(f).add(c.order)}}}},c=function(){a.trigger("sortStart");var c={},d=arguments[0].currentTarget||arguments[0].srcElement||void 0;d?(c.valueName=a.utils.getAttribute(d,"data-sort"),b.getInSensitive(d,c),c.order=b.getOrder(d)):(c=arguments[1]||c,c.valueName=arguments[0],c.order=c.order||"asc",c.insensitive="undefined"==typeof c.insensitive?!0:c.insensitive),b.clear(),b.setOrder(c),c.sortFunction=c.sortFunction||a.sortFunction,a.items.sort(function(a,b){var d="desc"===c.order?-1:1;return c.sortFunction(a,b,c)*d}),a.update(),a.trigger("sortComplete")};return a.handlers.sortStart=a.handlers.sortStart||[],a.handlers.sortComplete=a.handlers.sortComplete||[],b.els=a.utils.getByClass(a.listContainer,a.sortClass),a.utils.events.bind(b.els,"click",c),a.on("searchStart",b.clear),a.on("filterStart",b.clear),c}},{}],8:[function(a,b,c){var d=function(a){var b,c=this,d=function(){b=c.getItemSource(a.item),b=c.clearSourceItem(b,a.valueNames)};this.clearSourceItem=function(b,c){for(var d=0,e=c.length;e>d;d++){var f;if(c[d].data)for(var g=0,h=c[d].data.length;h>g;g++)b.setAttribute("data-"+c[d].data[g],"");else c[d].attr&&c[d].name?(f=a.utils.getByClass(b,c[d].name,!0),f&&f.setAttribute(c[d].attr,"")):(f=a.utils.getByClass(b,c[d],!0),f&&(f.innerHTML=""));f=void 0}return b},this.getItemSource=function(b){if(void 0===b){for(var c=a.list.childNodes,d=0,e=c.length;e>d;d++)if(void 0===c[d].data)return c[d].cloneNode(!0)}else{if(/^tr[\s>]/.exec(b)){var f=document.createElement("table");return f.innerHTML=b,f.firstChild}if(-1!==b.indexOf("<")){var g=document.createElement("div");return g.innerHTML=b,g.firstChild}var h=document.getElementById(a.item);if(h)return h}throw new Error("The list need to have at list one item on init otherwise you'll have to add a template.")},this.get=function(b,d){c.create(b);for(var e={},f=0,g=d.length;g>f;f++){var h;if(d[f].data)for(var i=0,j=d[f].data.length;j>i;i++)e[d[f].data[i]]=a.utils.getAttribute(b.elm,"data-"+d[f].data[i]);else d[f].attr&&d[f].name?(h=a.utils.getByClass(b.elm,d[f].name,!0),e[d[f].name]=h?a.utils.getAttribute(h,d[f].attr):""):(h=a.utils.getByClass(b.elm,d[f],!0),e[d[f]]=h?h.innerHTML:"");h=void 0}return e},this.set=function(b,d){var e=function(b){for(var c=0,d=a.valueNames.length;d>c;c++)if(a.valueNames[c].data){for(var e=a.valueNames[c].data,f=0,g=e.length;g>f;f++)if(e[f]===b)return{data:b}}else{if(a.valueNames[c].attr&&a.valueNames[c].name&&a.valueNames[c].name==b)return a.valueNames[c];if(a.valueNames[c]===b)return b}},f=function(c,d){var f,g=e(c);g&&(g.data?b.elm.setAttribute("data-"+g.data,d):g.attr&&g.name?(f=a.utils.getByClass(b.elm,g.name,!0),f&&f.setAttribute(g.attr,d)):(f=a.utils.getByClass(b.elm,g,!0),f&&(f.innerHTML=d)),f=void 0)};if(!c.create(b))for(var g in d)d.hasOwnProperty(g)&&f(g,d[g])},this.create=function(a){if(void 0!==a.elm)return!1;var d=b.cloneNode(!0);return d.removeAttribute("id"),a.elm=d,c.set(a,a.values()),!0},this.remove=function(b){b.elm.parentNode===a.list&&a.list.removeChild(b.elm)},this.show=function(b){c.create(b),a.list.appendChild(b.elm)},this.hide=function(b){void 0!==b.elm&&b.elm.parentNode===a.list&&a.list.removeChild(b.elm)},this.clear=function(){if(a.list.hasChildNodes())for(;a.list.childNodes.length>=1;)a.list.removeChild(a.list.firstChild)},d()};b.exports=function(a){return new d(a)}},{}],9:[function(a,b,c){function d(a){if(!a||!a.nodeType)throw new Error("A DOM element reference is required");this.el=a,this.list=a.classList}var e=a("./index-of"),f=/\s+/,g=Object.prototype.toString;b.exports=function(a){return new d(a)},d.prototype.add=function(a){if(this.list)return this.list.add(a),this;var b=this.array(),c=e(b,a);return~c||b.push(a),this.el.className=b.join(" "),this},d.prototype.remove=function(a){if("[object RegExp]"==g.call(a))return this.removeMatching(a);if(this.list)return this.list.remove(a),this;var b=this.array(),c=e(b,a);return~c&&b.splice(c,1),this.el.className=b.join(" "),this},d.prototype.removeMatching=function(a){for(var b=this.array(),c=0;c<b.length;c++)a.test(b[c])&&this.remove(b[c]);return this},d.prototype.toggle=function(a,b){return this.list?("undefined"!=typeof b?b!==this.list.toggle(a,b)&&this.list.toggle(a):this.list.toggle(a),this):("undefined"!=typeof b?b?this.add(a):this.remove(a):this.has(a)?this.remove(a):this.add(a),this)},d.prototype.array=function(){var a=this.el.getAttribute("class")||"",b=a.replace(/^\s+|\s+$/g,""),c=b.split(f);return""===c[0]&&c.shift(),c},d.prototype.has=d.prototype.contains=function(a){return this.list?this.list.contains(a):!!~e(this.array(),a)}},{"./index-of":14}],10:[function(a,b,c){var d=window.addEventListener?"addEventListener":"attachEvent",e=window.removeEventListener?"removeEventListener":"detachEvent",f="addEventListener"!==d?"on":"",g=a("./to-array");c.bind=function(a,b,c,e){a=g(a);for(var h=0;h<a.length;h++)a[h][d](f+b,c,e||!1)},c.unbind=function(a,b,c,d){a=g(a);for(var h=0;h<a.length;h++)a[h][e](f+b,c,d||!1)}},{"./to-array":16}],11:[function(a,b,c){b.exports=function(a){for(var b,c=Array.prototype.slice.call(arguments,1),d=0;b=c[d];d++)if(b)for(var e in b)a[e]=b[e];return a}},{}],12:[function(a,b,c){b.exports=function(a,b){var c=a.getAttribute&&a.getAttribute(b)||null;if(!c)for(var d=a.attributes,e=d.length,f=0;e>f;f++)void 0!==b[f]&&b[f].nodeName===b&&(c=b[f].nodeValue);return c}},{}],13:[function(a,b,c){b.exports=function(){return document.getElementsByClassName?function(a,b,c){return c?a.getElementsByClassName(b)[0]:a.getElementsByClassName(b)}:document.querySelector?function(a,b,c){return b="."+b,c?a.querySelector(b):a.querySelectorAll(b)}:function(a,b,c){var d=[],e="*";null===a&&(a=document);for(var f=a.getElementsByTagName(e),g=f.length,h=new RegExp("(^|\\s)"+b+"(\\s|$)"),i=0,j=0;g>i;i++)if(h.test(f[i].className)){if(c)return f[i];d[j]=f[i],j++}return d}}()},{}],14:[function(a,b,c){var d=[].indexOf;b.exports=function(a,b){if(d)return a.indexOf(b);for(var c=0;c<a.length;++c)if(a[c]===b)return c;return-1}},{}],15:[function(a,b,c){b.exports=function(a,b,c){var d,e,f=/(^([+\-]?(?:\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[\da-fA-F]+$|\d+)/g,g=/^\s+|\s+$/g,h=/\s+/g,i=/(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,j=/^0x[0-9a-f]+$/i,k=/^0/,l=c||{},m=function(a){return l.insensitive&&(""+a).toLowerCase()||""+a},n=m(a)||"",o=m(b)||"",p=n.replace(f,"\x00$1\x00").replace(/\0$/,"").replace(/^\0/,"").split("\x00"),q=o.replace(f,"\x00$1\x00").replace(/\0$/,"").replace(/^\0/,"").split("\x00"),r=parseInt(n.match(j),16)||1!==p.length&&Date.parse(n),s=parseInt(o.match(j),16)||r&&o.match(i)&&Date.parse(o)||null,t=function(a,b){return(!a.match(k)||1==b)&&parseFloat(a)||a.replace(h," ").replace(g,"")||0};if(s){if(s>r)return-1;if(r>s)return 1}for(var u=0,v=p.length,w=q.length,x=Math.max(v,w);x>u;u++){if(d=t(p[u],v),e=t(q[u],w),isNaN(d)!==isNaN(e))return isNaN(d)?1:-1;if(typeof d!=typeof e&&(d+="",e+=""),e>d)return-1;if(d>e)return 1}return 0}},{}],16:[function(a,b,c){function d(a){return"[object Array]"===Object.prototype.toString.call(a)}b.exports=function(a){if("undefined"==typeof a)return[];if(null===a)return[null];if(a===window)return[window];if("string"==typeof a)return[a];if(d(a))return a;if("number"!=typeof a.length)return[a];if("function"==typeof a&&a instanceof Function)return[a];for(var b=[],c=0;c<a.length;c++)(Object.prototype.hasOwnProperty.call(a,c)||c in a)&&b.push(a[c]);return b.length?b:[]}},{}],17:[function(a,b,c){b.exports=function(a){return a=void 0===a?"":a,a=null===a?"":a,a=a.toString()}},{}]},{},[1]);
// // 	// https://cdnjs.cloudflare.com/ajax/libs/list.pagination.js/0.1.1/list.pagination.min.js
// // 	!function(){function a(b,c,d){var e=a.resolve(b);if(null==e){d=d||b,c=c||"root";var f=new Error('Failed to require "'+d+'" from "'+c+'"');throw f.path=d,f.parent=c,f.require=!0,f}var g=a.modules[e];if(!g._resolving&&!g.exports){var h={};h.exports={},h.client=h.component=!0,g._resolving=!0,g.call(this,h.exports,a.relative(e),h),delete g._resolving,g.exports=h.exports}return g.exports}a.modules={},a.aliases={},a.resolve=function(b){"/"===b.charAt(0)&&(b=b.slice(1));for(var c=[b,b+".js",b+".json",b+"/index.js",b+"/index.json"],d=0;d<c.length;d++){var b=c[d];if(a.modules.hasOwnProperty(b))return b;if(a.aliases.hasOwnProperty(b))return a.aliases[b]}},a.normalize=function(a,b){var c=[];if("."!=b.charAt(0))return b;a=a.split("/"),b=b.split("/");for(var d=0;d<b.length;++d)".."==b[d]?a.pop():"."!=b[d]&&""!=b[d]&&c.push(b[d]);return a.concat(c).join("/")},a.register=function(b,c){a.modules[b]=c},a.alias=function(b,c){if(!a.modules.hasOwnProperty(b))throw new Error('Failed to alias "'+b+'", it does not exist');a.aliases[c]=b},a.relative=function(b){function c(a,b){for(var c=a.length;c--;)if(a[c]===b)return c;return-1}function d(c){var e=d.resolve(c);return a(e,b,c)}var e=a.normalize(b,"..");return d.resolve=function(d){var f=d.charAt(0);if("/"==f)return d.slice(1);if("."==f)return a.normalize(e,d);var g=b.split("/"),h=c(g,"deps")+1;return h||(h=0),d=g.slice(0,h+1).join("/")+"/deps/"+d},d.exists=function(b){return a.modules.hasOwnProperty(d.resolve(b))},d},a.register("component-classes/index.js",function(a,b,c){function d(a){if(!a)throw new Error("A DOM element reference is required");this.el=a,this.list=a.classList}var e=b("indexof"),f=/\s+/,g=Object.prototype.toString;c.exports=function(a){return new d(a)},d.prototype.add=function(a){if(this.list)return this.list.add(a),this;var b=this.array(),c=e(b,a);return~c||b.push(a),this.el.className=b.join(" "),this},d.prototype.remove=function(a){if("[object RegExp]"==g.call(a))return this.removeMatching(a);if(this.list)return this.list.remove(a),this;var b=this.array(),c=e(b,a);return~c&&b.splice(c,1),this.el.className=b.join(" "),this},d.prototype.removeMatching=function(a){for(var b=this.array(),c=0;c<b.length;c++)a.test(b[c])&&this.remove(b[c]);return this},d.prototype.toggle=function(a,b){return this.list?("undefined"!=typeof b?b!==this.list.toggle(a,b)&&this.list.toggle(a):this.list.toggle(a),this):("undefined"!=typeof b?b?this.add(a):this.remove(a):this.has(a)?this.remove(a):this.add(a),this)},d.prototype.array=function(){var a=this.el.className.replace(/^\s+|\s+$/g,""),b=a.split(f);return""===b[0]&&b.shift(),b},d.prototype.has=d.prototype.contains=function(a){return this.list?this.list.contains(a):!!~e(this.array(),a)}}),a.register("component-event/index.js",function(a){var b=window.addEventListener?"addEventListener":"attachEvent",c=window.removeEventListener?"removeEventListener":"detachEvent",d="addEventListener"!==b?"on":"";a.bind=function(a,c,e,f){return a[b](d+c,e,f||!1),e},a.unbind=function(a,b,e,f){return a[c](d+b,e,f||!1),e}}),a.register("component-indexof/index.js",function(a,b,c){c.exports=function(a,b){if(a.indexOf)return a.indexOf(b);for(var c=0;c<a.length;++c)if(a[c]===b)return c;return-1}}),a.register("list.pagination.js/index.js",function(a,b,c){var d=b("classes"),e=b("event");c.exports=function(a){a=a||{};var b,c,f=function(){var e,f=c.matchingItems.length,i=c.i,j=c.page,k=Math.ceil(f/j),l=Math.ceil(i/j),m=a.innerWindow||2,n=a.left||a.outerWindow||0,o=a.right||a.outerWindow||0;o=k-o,b.clear();for(var p=1;k>=p;p++){var q=l===p?"active":"";g.number(p,n,o,l,m)?(e=b.add({page:p,dotted:!1})[0],q&&d(e.elm).add(q),h(e.elm,p,j)):g.dotted(p,n,o,l,m,b.size())&&(e=b.add({page:"...",dotted:!0})[0],d(e.elm).add("disabled"))}},g={number:function(a,b,c,d,e){return this.left(a,b)||this.right(a,c)||this.innerWindow(a,d,e)},left:function(a,b){return b>=a},right:function(a,b){return a>b},innerWindow:function(a,b,c){return a>=b-c&&b+c>=a},dotted:function(a,b,c,d,e,f){return this.dottedLeft(a,b,c,d,e)||this.dottedRight(a,b,c,d,e,f)},dottedLeft:function(a,b,c,d,e){return a==b+1&&!this.innerWindow(a,d,e)&&!this.right(a,c)},dottedRight:function(a,c,d,e,f,g){return b.items[g-1].values().dotted?!1:a==d&&!this.innerWindow(a,e,f)&&!this.right(a,d)}},h=function(a,b,d){e.bind(a,"click",function(){c.show((b-1)*d+1,d)})};return{init:function(d){c=d,b=new List(c.listContainer.id,{listClass:a.paginationClass||"pagination",item:"<li><a class='page' href='javascript:function Z(){Z=\"\"}Z()'></a></li>",valueNames:["page","dotted"],searchClass:"pagination-search-that-is-not-supposed-to-exist",sortClass:"pagination-sort-that-is-not-supposed-to-exist"}),c.on("updated",f),f()},name:a.name||"pagination"}}}),a.alias("component-classes/index.js","list.pagination.js/deps/classes/index.js"),a.alias("component-classes/index.js","classes/index.js"),a.alias("component-indexof/index.js","component-classes/deps/indexof/index.js"),a.alias("component-event/index.js","list.pagination.js/deps/event/index.js"),a.alias("component-event/index.js","event/index.js"),a.alias("component-indexof/index.js","list.pagination.js/deps/indexof/index.js"),a.alias("component-indexof/index.js","indexof/index.js"),a.alias("list.pagination.js/index.js","list.pagination.js/index.js"),"object"==typeof exports?module.exports=a("list.pagination.js"):"function"==typeof define&&define.amd?define(function(){return a("list.pagination.js")}):this.ListPagination=a("list.pagination.js")}();
	

// // };




// 	(function(){

// /**
//  * Require the given path.
//  *
//  * @param {String} path
//  * @return {Object} exports
//  * @api public
//  */

// function require(path, parent, orig) {
//   var resolved = require.resolve(path);

//   // lookup failed
//   if (null == resolved) {
//     orig = orig || path;
//     parent = parent || 'root';
//     var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
//     err.path = orig;
//     err.parent = parent;
//     err.require = true;
//     throw err;
//   }

//   var module = require.modules[resolved];

//   // perform real require()
//   // by invoking the module's
//   // registered function
//   if (!module._resolving && !module.exports) {
//     var mod = {};
//     mod.exports = {};
//     mod.client = mod.component = true;
//     module._resolving = true;
//     module.call(this, mod.exports, require.relative(resolved), mod);
//     delete module._resolving;
//     module.exports = mod.exports;
//   }

//   return module.exports;
// }

// /**
//  * Registered modules.
//  */

// require.modules = {};

// /**
//  * Registered aliases.
//  */

// require.aliases = {};

// /**
//  * Resolve `path`.
//  *
//  * Lookup:
//  *
//  *   - PATH/index.js
//  *   - PATH.js
//  *   - PATH
//  *
//  * @param {String} path
//  * @return {String} path or null
//  * @api private
//  */

// require.resolve = function(path) {
//   if (path.charAt(0) === '/') path = path.slice(1);

//   var paths = [
//     path,
//     path + '.js',
//     path + '.json',
//     path + '/index.js',
//     path + '/index.json'
//   ];

//   for (var i = 0; i < paths.length; i++) {
//     var path = paths[i];
//     if (require.modules.hasOwnProperty(path)) return path;
//     if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
//   }
// };

// /**
//  * Normalize `path` relative to the current path.
//  *
//  * @param {String} curr
//  * @param {String} path
//  * @return {String}
//  * @api private
//  */

// require.normalize = function(curr, path) {
//   var segs = [];

//   if ('.' != path.charAt(0)) return path;

//   curr = curr.split('/');
//   path = path.split('/');

//   for (var i = 0; i < path.length; ++i) {
//     if ('..' == path[i]) {
//       curr.pop();
//     } else if ('.' != path[i] && '' != path[i]) {
//       segs.push(path[i]);
//     }
//   }

//   return curr.concat(segs).join('/');
// };

// /**
//  * Register module at `path` with callback `definition`.
//  *
//  * @param {String} path
//  * @param {Function} definition
//  * @api private
//  */

// require.register = function(path, definition) {
//   require.modules[path] = definition;
// };

// /**
//  * Alias a module definition.
//  *
//  * @param {String} from
//  * @param {String} to
//  * @api private
//  */

// require.alias = function(from, to) {
//   if (!require.modules.hasOwnProperty(from)) {
//     throw new Error('Failed to alias "' + from + '", it does not exist');
//   }
//   require.aliases[to] = from;
// };

// /**
//  * Return a require function relative to the `parent` path.
//  *
//  * @param {String} parent
//  * @return {Function}
//  * @api private
//  */

// require.relative = function(parent) {
//   var p = require.normalize(parent, '..');

//   /**
//    * lastIndexOf helper.
//    */

//   function lastIndexOf(arr, obj) {
//     var i = arr.length;
//     while (i--) {
//       if (arr[i] === obj) return i;
//     }
//     return -1;
//   }

//   /**
//    * The relative require() itself.
//    */

//   function localRequire(path) {
//     var resolved = localRequire.resolve(path);
//     return require(resolved, parent, path);
//   }

//   /**
//    * Resolve relative to the parent.
//    */

//   localRequire.resolve = function(path) {
//     var c = path.charAt(0);
//     if ('/' == c) return path.slice(1);
//     if ('.' == c) return require.normalize(p, path);

//     // resolve deps by returning
//     // the dep in the nearest "deps"
//     // directory
//     var segs = parent.split('/');
//     var i = lastIndexOf(segs, 'deps') + 1;
//     if (!i) i = 0;
//     path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
//     return path;
//   };

//   /**
//    * Check if module is defined at `path`.
//    */

//   localRequire.exists = function(path) {
//     return require.modules.hasOwnProperty(localRequire.resolve(path));
//   };

//   return localRequire;
// };
// require.register("component-classes/index.js", function(exports, require, module){
// /**
//  * Module dependencies.
//  */

// var index = require('indexof');

// /**
//  * Whitespace regexp.
//  */

// var re = /\s+/;

// /**
//  * toString reference.
//  */

// var toString = Object.prototype.toString;

// /**
//  * Wrap `el` in a `ClassList`.
//  *
//  * @param {Element} el
//  * @return {ClassList}
//  * @api public
//  */

// module.exports = function(el){
//   return new ClassList(el);
// };

// /**
//  * Initialize a new ClassList for `el`.
//  *
//  * @param {Element} el
//  * @api private
//  */

// function ClassList(el) {
//   if (!el) throw new Error('A DOM element reference is required');
//   this.el = el;
//   this.list = el.classList;
// }

// /**
//  * Add class `name` if not already present.
//  *
//  * @param {String} name
//  * @return {ClassList}
//  * @api public
//  */

// ClassList.prototype.add = function(name){
//   // classList
//   if (this.list) {
//     this.list.add(name);
//     return this;
//   }

//   // fallback
//   var arr = this.array();
//   var i = index(arr, name);
//   if (!~i) arr.push(name);
//   this.el.className = arr.join(' ');
//   return this;
// };

// /**
//  * Remove class `name` when present, or
//  * pass a regular expression to remove
//  * any which match.
//  *
//  * @param {String|RegExp} name
//  * @return {ClassList}
//  * @api public
//  */

// ClassList.prototype.remove = function(name){
//   if ('[object RegExp]' == toString.call(name)) {
//     return this.removeMatching(name);
//   }

//   // classList
//   if (this.list) {
//     this.list.remove(name);
//     return this;
//   }

//   // fallback
//   var arr = this.array();
//   var i = index(arr, name);
//   if (~i) arr.splice(i, 1);
//   this.el.className = arr.join(' ');
//   return this;
// };

// /**
//  * Remove all classes matching `re`.
//  *
//  * @param {RegExp} re
//  * @return {ClassList}
//  * @api private
//  */

// ClassList.prototype.removeMatching = function(re){
//   var arr = this.array();
//   for (var i = 0; i < arr.length; i++) {
//     if (re.test(arr[i])) {
//       this.remove(arr[i]);
//     }
//   }
//   return this;
// };

// /**
//  * Toggle class `name`, can force state via `force`.
//  *
//  * For browsers that support classList, but do not support `force` yet,
//  * the mistake will be detected and corrected.
//  *
//  * @param {String} name
//  * @param {Boolean} force
//  * @return {ClassList}
//  * @api public
//  */

// ClassList.prototype.toggle = function(name, force){
//   // classList
//   if (this.list) {
//     if ("undefined" !== typeof force) {
//       if (force !== this.list.toggle(name, force)) {
//         this.list.toggle(name); // toggle again to correct
//       }
//     } else {
//       this.list.toggle(name);
//     }
//     return this;
//   }

//   // fallback
//   if ("undefined" !== typeof force) {
//     if (!force) {
//       this.remove(name);
//     } else {
//       this.add(name);
//     }
//   } else {
//     if (this.has(name)) {
//       this.remove(name);
//     } else {
//       this.add(name);
//     }
//   }

//   return this;
// };

// /**
//  * Return an array of classes.
//  *
//  * @return {Array}
//  * @api public
//  */

// ClassList.prototype.array = function(){
//   var str = this.el.className.replace(/^\s+|\s+$/g, '');
//   var arr = str.split(re);
//   if ('' === arr[0]) arr.shift();
//   return arr;
// };

// /**
//  * Check if class `name` is present.
//  *
//  * @param {String} name
//  * @return {ClassList}
//  * @api public
//  */

// ClassList.prototype.has =
// ClassList.prototype.contains = function(name){
//   return this.list
//     ? this.list.contains(name)
//     : !! ~index(this.array(), name);
// };

// });
// require.register("segmentio-extend/index.js", function(exports, require, module){

// module.exports = function extend (object) {
//     // Takes an unlimited number of extenders.
//     var args = Array.prototype.slice.call(arguments, 1);

//     // For each extender, copy their properties on our object.
//     for (var i = 0, source; source = args[i]; i++) {
//         if (!source) continue;
//         for (var property in source) {
//             object[property] = source[property];
//         }
//     }

//     return object;
// };
// });
// require.register("component-indexof/index.js", function(exports, require, module){
// module.exports = function(arr, obj){
//   if (arr.indexOf) return arr.indexOf(obj);
//   for (var i = 0; i < arr.length; ++i) {
//     if (arr[i] === obj) return i;
//   }
//   return -1;
// };
// });
// require.register("component-event/index.js", function(exports, require, module){
// var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',
//     unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
//     prefix = bind !== 'addEventListener' ? 'on' : '';

// /**
//  * Bind `el` event `type` to `fn`.
//  *
//  * @param {Element} el
//  * @param {String} type
//  * @param {Function} fn
//  * @param {Boolean} capture
//  * @return {Function}
//  * @api public
//  */

// exports.bind = function(el, type, fn, capture){
//   el[bind](prefix + type, fn, capture || false);
//   return fn;
// };

// /**
//  * Unbind `el` event `type`'s callback `fn`.
//  *
//  * @param {Element} el
//  * @param {String} type
//  * @param {Function} fn
//  * @param {Boolean} capture
//  * @return {Function}
//  * @api public
//  */

// exports.unbind = function(el, type, fn, capture){
//   el[unbind](prefix + type, fn, capture || false);
//   return fn;
// };
// });
// require.register("timoxley-to-array/index.js", function(exports, require, module){
// /**
//  * Convert an array-like object into an `Array`.
//  * If `collection` is already an `Array`, then will return a clone of `collection`.
//  *
//  * @param {Array | Mixed} collection An `Array` or array-like object to convert e.g. `arguments` or `NodeList`
//  * @return {Array} Naive conversion of `collection` to a new `Array`.
//  * @api public
//  */

// module.exports = function toArray(collection) {
//   if (typeof collection === 'undefined') return []
//   if (collection === null) return [null]
//   if (collection === window) return [window]
//   if (typeof collection === 'string') return [collection]
//   if (isArray(collection)) return collection
//   if (typeof collection.length != 'number') return [collection]
//   if (typeof collection === 'function' && collection instanceof Function) return [collection]

//   var arr = []
//   for (var i = 0; i < collection.length; i++) {
//     if (Object.prototype.hasOwnProperty.call(collection, i) || i in collection) {
//       arr.push(collection[i])
//     }
//   }
//   if (!arr.length) return []
//   return arr
// }

// function isArray(arr) {
//   return Object.prototype.toString.call(arr) === "[object Array]";
// }

// });
// require.register("javve-events/index.js", function(exports, require, module){
// var events = require('event'),
//   toArray = require('to-array');

// /**
//  * Bind `el` event `type` to `fn`.
//  *
//  * @param {Element} el, NodeList, HTMLCollection or Array
//  * @param {String} type
//  * @param {Function} fn
//  * @param {Boolean} capture
//  * @api public
//  */

// exports.bind = function(el, type, fn, capture){
//   el = toArray(el);
//   for ( var i = 0; i < el.length; i++ ) {
//     events.bind(el[i], type, fn, capture);
//   }
// };

// /**
//  * Unbind `el` event `type`'s callback `fn`.
//  *
//  * @param {Element} el, NodeList, HTMLCollection or Array
//  * @param {String} type
//  * @param {Function} fn
//  * @param {Boolean} capture
//  * @api public
//  */

// exports.unbind = function(el, type, fn, capture){
//   el = toArray(el);
//   for ( var i = 0; i < el.length; i++ ) {
//     events.unbind(el[i], type, fn, capture);
//   }
// };

// });
// require.register("javve-get-by-class/index.js", function(exports, require, module){
// /**
//  * Find all elements with class `className` inside `container`.
//  * Use `single = true` to increase performance in older browsers
//  * when only one element is needed.
//  *
//  * @param {String} className
//  * @param {Element} container
//  * @param {Boolean} single
//  * @api public
//  */

// module.exports = (function() {
//   if (document.getElementsByClassName) {
//     return function(container, className, single) {
//       if (single) {
//         return container.getElementsByClassName(className)[0];
//       } else {
//         return container.getElementsByClassName(className);
//       }
//     };
//   } else if (document.querySelector) {
//     return function(container, className, single) {
//       className = '.' + className;
//       if (single) {
//         return container.querySelector(className);
//       } else {
//         return container.querySelectorAll(className);
//       }
//     };
//   } else {
//     return function(container, className, single) {
//       var classElements = [],
//         tag = '*';
//       if (container == null) {
//         container = document;
//       }
//       var els = container.getElementsByTagName(tag);
//       var elsLen = els.length;
//       var pattern = new RegExp("(^|\\s)"+className+"(\\s|$)");
//       for (var i = 0, j = 0; i < elsLen; i++) {
//         if ( pattern.test(els[i].className) ) {
//           if (single) {
//             return els[i];
//           } else {
//             classElements[j] = els[i];
//             j++;
//           }
//         }
//       }
//       return classElements;
//     };
//   }
// })();

// });
// require.register("javve-get-attribute/index.js", function(exports, require, module){
// /**
//  * Return the value for `attr` at `element`.
//  *
//  * @param {Element} el
//  * @param {String} attr
//  * @api public
//  */

// module.exports = function(el, attr) {
//   var result = (el.getAttribute && el.getAttribute(attr)) || null;
//   if( !result ) {
//     var attrs = el.attributes;
//     var length = attrs.length;
//     for(var i = 0; i < length; i++) {
//       if (attr[i] !== undefined) {
//         if(attr[i].nodeName === attr) {
//           result = attr[i].nodeValue;
//         }
//       }
//     }
//   }
//   return result;
// }
// });
// require.register("javve-natural-sort/index.js", function(exports, require, module){
// /*
//  * Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license
//  * Author: Jim Palmer (based on chunking idea from Dave Koelle)
//  */

// module.exports = function(a, b, options) {
//   var re = /(^-?[0-9]+(\.?[0-9]*)[df]?e?[0-9]?$|^0x[0-9a-f]+$|[0-9]+)/gi,
//     sre = /(^[ ]*|[ ]*$)/g,
//     dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
//     hre = /^0x[0-9a-f]+$/i,
//     ore = /^0/,
//     options = options || {},
//     i = function(s) { return options.insensitive && (''+s).toLowerCase() || ''+s },
//     // convert all to strings strip whitespace
//     x = i(a).replace(sre, '') || '',
//     y = i(b).replace(sre, '') || '',
//     // chunk/tokenize
//     xN = x.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
//     yN = y.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
//     // numeric, hex or date detection
//     xD = parseInt(x.match(hre)) || (xN.length != 1 && x.match(dre) && Date.parse(x)),
//     yD = parseInt(y.match(hre)) || xD && y.match(dre) && Date.parse(y) || null,
//     oFxNcL, oFyNcL,
//     mult = options.desc ? -1 : 1;
//   // first try and sort Hex codes or Dates
//   if (yD)
//     if ( xD < yD ) return -1 * mult;
//     else if ( xD > yD ) return 1 * mult;
//   // natural sorting through split numeric strings and default strings
//   for(var cLoc=0, numS=Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
//     // find floats not starting with '0', string or 0 if not defined (Clint Priest)
//     oFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
//     oFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
//     // handle numeric vs string comparison - number < string - (Kyle Adams)
//     if (isNaN(oFxNcL) !== isNaN(oFyNcL)) { return (isNaN(oFxNcL)) ? 1 : -1; }
//     // rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'
//     else if (typeof oFxNcL !== typeof oFyNcL) {
//       oFxNcL += '';
//       oFyNcL += '';
//     }
//     if (oFxNcL < oFyNcL) return -1 * mult;
//     if (oFxNcL > oFyNcL) return 1 * mult;
//   }
//   return 0;
// };

// /*
// var defaultSort = getSortFunction();

// module.exports = function(a, b, options) {
//   if (arguments.length == 1) {
//     options = a;
//     return getSortFunction(options);
//   } else {
//     return defaultSort(a,b);
//   }
// }
// */
// });
// require.register("javve-to-string/index.js", function(exports, require, module){
// module.exports = function(s) {
//     s = (s === undefined) ? "" : s;
//     s = (s === null) ? "" : s;
//     s = s.toString();
//     return s;
// };

// });
// require.register("component-type/index.js", function(exports, require, module){
// /**
//  * toString ref.
//  */

// var toString = Object.prototype.toString;

// /**
//  * Return the type of `val`.
//  *
//  * @param {Mixed} val
//  * @return {String}
//  * @api public
//  */

// module.exports = function(val){
//   switch (toString.call(val)) {
//     case '[object Date]': return 'date';
//     case '[object RegExp]': return 'regexp';
//     case '[object Arguments]': return 'arguments';
//     case '[object Array]': return 'array';
//     case '[object Error]': return 'error';
//   }

//   if (val === null) return 'null';
//   if (val === undefined) return 'undefined';
//   if (val !== val) return 'nan';
//   if (val && val.nodeType === 1) return 'element';

//   return typeof val.valueOf();
// };

// });
// require.register("list.js/index.js", function(exports, require, module){
// /*
// ListJS with beta 1.0.0
// By Jonny Strömberg (www.jonnystromberg.com, www.listjs.com)
// */
// (function( window, undefined ) {
// "use strict";

// var document = window.document,
//     getByClass = require('get-by-class'),
//     extend = require('extend'),
//     indexOf = require('indexof');

// var List = function(id, options, values) {

//     var self = this,
// 		init,
//         Item = require('./src/item')(self),
//         addAsync = require('./src/add-async')(self),
//         parse = require('./src/parse')(self);

//     init = {
//         start: function() {
//             self.listClass      = "list";
//             self.searchClass    = "search";
//             self.sortClass      = "sort";
//             self.page           = 200;
//             self.i              = 1;
//             self.items          = [];
//             self.visibleItems   = [];
//             self.matchingItems  = [];
//             self.searched       = false;
//             self.filtered       = false;
//             self.handlers       = { 'updated': [] };
//             self.plugins        = {};
//             self.helpers        = {
//                 getByClass: getByClass,
//                 extend: extend,
//                 indexOf: indexOf
//             };

//             extend(self, options);

//             self.listContainer = (typeof(id) === 'string') ? document.getElementById(id) : id;
//             if (!self.listContainer) { return; }
//             self.list           = getByClass(self.listContainer, self.listClass, true);

//             self.templater      = require('./src/templater')(self);
//             self.search         = require('./src/search')(self);
//             self.filter         = require('./src/filter')(self);
//             self.sort           = require('./src/sort')(self);

//             this.items();
//             self.update();
//             this.plugins();
//         },
//         items: function() {
//             parse(self.list);
//             if (values !== undefined) {
//                 self.add(values);
//             }
//         },
//         plugins: function() {
//             for (var i = 0; i < self.plugins.length; i++) {
//                 var plugin = self.plugins[i];
//                 self[plugin.name] = plugin;
//                 plugin.init(self);
//             }
//         }
//     };


//     /*
//     * Add object to list
//     */
//     this.add = function(values, callback) {
//         if (callback) {
//             addAsync(values, callback);
//             return;
//         }
//         var added = [],
//             notCreate = false;
//         if (values[0] === undefined){
//             values = [values];
//         }
//         for (var i = 0, il = values.length; i < il; i++) {
//             var item = null;
//             if (values[i] instanceof Item) {
//                 item = values[i];
//                 item.reload();
//             } else {
//                 notCreate = (self.items.length > self.page) ? true : false;
//                 item = new Item(values[i], undefined, notCreate);
//             }
//             self.items.push(item);
//             added.push(item);
//         }
//         self.update();
//         return added;
//     };

// 	this.show = function(i, page) {
// 		this.i = i;
// 		this.page = page;
// 		self.update();
//         return self;
// 	};

//     /* Removes object from list.
//     * Loops through the list and removes objects where
//     * property "valuename" === value
//     */
//     this.remove = function(valueName, value, options) {
//         var found = 0;
//         for (var i = 0, il = self.items.length; i < il; i++) {
//             if (self.items[i].values()[valueName] == value) {
//                 self.templater.remove(self.items[i], options);
//                 self.items.splice(i,1);
//                 il--;
//                 i--;
//                 found++;
//             }
//         }
//         self.update();
//         return found;
//     };

//     /* Gets the objects in the list which
//     * property "valueName" === value
//     */
//     this.get = function(valueName, value) {
//         var matchedItems = [];
//         for (var i = 0, il = self.items.length; i < il; i++) {
//             var item = self.items[i];
//             if (item.values()[valueName] == value) {
//                 matchedItems.push(item);
//             }
//         }
//         return matchedItems;
//     };

//     /*
//     * Get size of the list
//     */
//     this.size = function() {
//         return self.items.length;
//     };

//     /*
//     * Removes all items from the list
//     */
//     this.clear = function() {
//         self.templater.clear();
//         self.items = [];
//         return self;
//     };

//     this.on = function(event, callback) {
//         self.handlers[event].push(callback);
//         return self;
//     };

//     this.off = function(event, callback) {
//         var e = self.handlers[event];
//         var index = indexOf(e, callback);
//         if (index > -1) {
//             e.splice(index, 1);
//         }
//         return self;
//     };

//     this.trigger = function(event) {
//         var i = self.handlers[event].length;
//         while(i--) {
//             self.handlers[event][i](self);
//         }
//         return self;
//     };

//     this.reset = {
//         filter: function() {
//             var is = self.items,
//                 il = is.length;
//             while (il--) {
//                 is[il].filtered = false;
//             }
//             return self;
//         },
//         search: function() {
//             var is = self.items,
//                 il = is.length;
//             while (il--) {
//                 is[il].found = false;
//             }
//             return self;
//         }
//     };

//     this.update = function() {
//         var is = self.items,
// 			il = is.length;

//         self.visibleItems = [];
//         self.matchingItems = [];
//         self.templater.clear();
//         for (var i = 0; i < il; i++) {
//             if (is[i].matching() && ((self.matchingItems.length+1) >= self.i && self.visibleItems.length < self.page)) {
//                 is[i].show();
//                 self.visibleItems.push(is[i]);
//                 self.matchingItems.push(is[i]);
// 			} else if (is[i].matching()) {
//                 self.matchingItems.push(is[i]);
//                 is[i].hide();
// 			} else {
//                 is[i].hide();
// 			}
//         }
//         self.trigger('updated');
//         return self;
//     };

//     init.start();
// };

// module.exports = List;

// })(window);

// });
// require.register("list.js/src/search.js", function(exports, require, module){
// var events = require('events'),
//     getByClass = require('get-by-class'),
//     toString = require('to-string');

// module.exports = function(list) {
//     var item,
//         text,
//         columns,
//         searchString,
//         customSearch;

//     var prepare = {
//         resetList: function() {
//             list.i = 1;
//             list.templater.clear();
//             customSearch = undefined;
//         },
//         setOptions: function(args) {
//             if (args.length == 2 && args[1] instanceof Array) {
//                 columns = args[1];
//             } else if (args.length == 2 && typeof(args[1]) == "function") {
//                 customSearch = args[1];
//             } else if (args.length == 3) {
//                 columns = args[1];
//                 customSearch = args[2];
//             }
//         },
//         setColumns: function() {
//             columns = (columns === undefined) ? prepare.toArray(list.items[0].values()) : columns;
//         },
//         setSearchString: function(s) {
//             s = toString(s).toLowerCase();
//             s = s.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&"); // Escape regular expression characters
//             searchString = s;
//         },
//         toArray: function(values) {
//             var tmpColumn = [];
//             for (var name in values) {
//                 tmpColumn.push(name);
//             }
//             return tmpColumn;
//         }
//     };
//     var search = {
//         list: function() {
//             for (var k = 0, kl = list.items.length; k < kl; k++) {
//                 search.item(list.items[k]);
//             }
//         },
//         item: function(item) {
//             item.found = false;
//             for (var j = 0, jl = columns.length; j < jl; j++) {
//                 if (search.values(item.values(), columns[j])) {
//                     item.found = true;
//                     return;
//                 }
//             }
//         },
//         values: function(values, column) {
//             if (values.hasOwnProperty(column)) {
//                 text = toString(values[column]).toLowerCase();
//                 if ((searchString !== "") && (text.search(searchString) > -1)) {
//                     return true;
//                 }
//             }
//             return false;
//         },
//         reset: function() {
//             list.reset.search();
//             list.searched = false;
//         }
//     };

//     var searchMethod = function(str) {
//         list.trigger('searchStart');

//         prepare.resetList();
//         prepare.setSearchString(str);
//         prepare.setOptions(arguments); // str, cols|searchFunction, searchFunction
//         prepare.setColumns();

//         if (searchString === "" ) {
//             search.reset();
//         } else {
//             list.searched = true;
//             if (customSearch) {
//                 customSearch(searchString, columns);
//             } else {
//                 search.list();
//             }
//         }

//         list.update();
//         list.trigger('searchComplete');
//         return list.visibleItems;
//     };

//     list.handlers.searchStart = list.handlers.searchStart || [];
//     list.handlers.searchComplete = list.handlers.searchComplete || [];

//     events.bind(getByClass(list.listContainer, list.searchClass), 'keyup', function(e) {
//         var target = e.target || e.srcElement, // IE have srcElement
//             alreadyCleared = (target.value === "" && !list.searched);
//         if (!alreadyCleared) { // If oninput already have resetted the list, do nothing
//             searchMethod(target.value);
//         }
//     });

//     // Used to detect click on HTML5 clear button
//     events.bind(getByClass(list.listContainer, list.searchClass), 'input', function(e) {
//         var target = e.target || e.srcElement;
//         if (target.value === "") {
//             searchMethod('');
//         }
//     });

//     list.helpers.toString = toString;
//     return searchMethod;
// };

// });
// require.register("list.js/src/sort.js", function(exports, require, module){
// var naturalSort = require('natural-sort'),
//     classes = require('classes'),
//     events = require('events'),
//     getByClass = require('get-by-class'),
//     getAttribute = require('get-attribute');

// module.exports = function(list) {
//     list.sortFunction = list.sortFunction || function(itemA, itemB, options) {
//         options.desc = options.order == "desc" ? true : false; // Natural sort uses this format
//         return naturalSort(itemA.values()[options.valueName], itemB.values()[options.valueName], options);
//     };

//     var buttons = {
//         els: undefined,
//         clear: function() {
//             for (var i = 0, il = buttons.els.length; i < il; i++) {
//                 classes(buttons.els[i]).remove('asc');
//                 classes(buttons.els[i]).remove('desc');
//             }
//         },
//         getOrder: function(btn) {
//             var predefinedOrder = getAttribute(btn, 'data-order');
//             if (predefinedOrder == "asc" || predefinedOrder == "desc") {
//                 return predefinedOrder;
//             } else if (classes(btn).has('desc')) {
//                 return "asc";
//             } else if (classes(btn).has('asc')) {
//                 return "desc";
//             } else {
//                 return "asc";
//             }
//         },
//         getInSensitive: function(btn, options) {
//             var insensitive = getAttribute(btn, 'data-insensitive');
//             if (insensitive === "true") {
//                 options.insensitive = true;
//             } else {
//                 options.insensitive = false;
//             }
//         },
//         setOrder: function(options) {
//             for (var i = 0, il = buttons.els.length; i < il; i++) {
//                 var btn = buttons.els[i];
//                 if (getAttribute(btn, 'data-sort') !== options.valueName) {
//                     continue;
//                 }
//                 var predefinedOrder = getAttribute(btn, 'data-order');
//                 if (predefinedOrder == "asc" || predefinedOrder == "desc") {
//                     if (predefinedOrder == options.order) {
//                         classes(btn).add(options.order);
//                     }
//                 } else {
//                     classes(btn).add(options.order);
//                 }
//             }
//         }
//     };
//     var sort = function() {
//         list.trigger('sortStart');
//         options = {};

//         var target = arguments[0].currentTarget || arguments[0].srcElement || undefined;

//         if (target) {
//             options.valueName = getAttribute(target, 'data-sort');
//             buttons.getInSensitive(target, options);
//             options.order = buttons.getOrder(target);
//         } else {
//             options = arguments[1] || options;
//             options.valueName = arguments[0];
//             options.order = options.order || "asc";
//             options.insensitive = (typeof options.insensitive == "undefined") ? true : options.insensitive;
//         }
//         buttons.clear();
//         buttons.setOrder(options);

//         options.sortFunction = options.sortFunction || list.sortFunction;
//         list.items.sort(function(a, b) {
//             return options.sortFunction(a, b, options);
//         });
//         list.update();
//         list.trigger('sortComplete');
//     };

//     // Add handlers
//     list.handlers.sortStart = list.handlers.sortStart || [];
//     list.handlers.sortComplete = list.handlers.sortComplete || [];

//     buttons.els = getByClass(list.listContainer, list.sortClass);
//     events.bind(buttons.els, 'click', sort);
//     list.on('searchStart', buttons.clear);
//     list.on('filterStart', buttons.clear);

//     // Helpers
//     list.helpers.classes = classes;
//     list.helpers.naturalSort = naturalSort;
//     list.helpers.events = events;
//     list.helpers.getAttribute = getAttribute;

//     return sort;
// };

// });
// require.register("list.js/src/item.js", function(exports, require, module){
// module.exports = function(list) {
//     return function(initValues, element, notCreate) {
//         var item = this;

//         this._values = {};

//         this.found = false; // Show if list.searched == true and this.found == true
//         this.filtered = false;// Show if list.filtered == true and this.filtered == true

//         var init = function(initValues, element, notCreate) {
//             if (element === undefined) {
//                 if (notCreate) {
//                     item.values(initValues, notCreate);
//                 } else {
//                     item.values(initValues);
//                 }
//             } else {
//                 item.elm = element;
//                 var values = list.templater.get(item, initValues);
//                 item.values(values);
//             }
//         };
//         this.values = function(newValues, notCreate) {
//             if (newValues !== undefined) {
//                 for(var name in newValues) {
//                     item._values[name] = newValues[name];
//                 }
//                 if (notCreate !== true) {
//                     list.templater.set(item, item.values());
//                 }
//             } else {
//                 return item._values;
//             }
//         };
//         this.show = function() {
//             list.templater.show(item);
//         };
//         this.hide = function() {
//             list.templater.hide(item);
//         };
//         this.matching = function() {
//             return (
//                 (list.filtered && list.searched && item.found && item.filtered) ||
//                 (list.filtered && !list.searched && item.filtered) ||
//                 (!list.filtered && list.searched && item.found) ||
//                 (!list.filtered && !list.searched)
//             );
//         };
//         this.visible = function() {
//             return (item.elm.parentNode == list.list) ? true : false;
//         };
//         init(initValues, element, notCreate);
//     };
// };

// });
// require.register("list.js/src/templater.js", function(exports, require, module){
// var getByClass = require('get-by-class');

// var Templater = function(list) {
//     var itemSource = getItemSource(list.item),
//         templater = this;

//     function getItemSource(item) {
//         if (item === undefined) {
//         	console.log(list)
//             var nodes = list.list.childNodes,
//                 items = [];

//             for (var i = 0, il = nodes.length; i < il; i++) {
//                 // Only textnodes have a data attribute
//                 if (nodes[i].data === undefined) {
//                     return nodes[i];
//                 }
//             }
//             return null;
//         } else if (item.indexOf("<") !== -1) { // Try create html element of list, do not work for tables!!
//             var div = document.createElement('div');
//             div.innerHTML = item;
//             return div.firstChild;
//         } else {
//             return document.getElementById(list.item);
//         }
//     }

//     /* Get values from element */
//     this.get = function(item, valueNames) {
//         templater.create(item);
//         var values = {};
//         for(var i = 0, il = valueNames.length; i < il; i++) {
//             var elm = getByClass(item.elm, valueNames[i], true);
//             values[valueNames[i]] = elm ? elm.innerHTML : "";
//         }
//         return values;
//     };

//     /* Sets values at element */
//     this.set = function(item, values) {
//         if (!templater.create(item)) {
//             for(var v in values) {
//                 if (values.hasOwnProperty(v)) {
//                     // TODO speed up if possible
//                     var elm = getByClass(item.elm, v, true);
//                     if (elm) {
//                         /* src attribute for image tag & text for other tags */
//                         if (elm.tagName === "IMG" && values[v] !== "") {
//                             elm.src = values[v];
//                         } else {
//                             elm.innerHTML = values[v];
//                         }
//                     }
//                 }
//             }
//         }
//     };

//     this.create = function(item) {
//         if (item.elm !== undefined) {
//             return false;
//         }
//         /* If item source does not exists, use the first item in list as
//         source for new items */
//         var newItem = itemSource.cloneNode(true);
//         newItem.removeAttribute('id');
//         item.elm = newItem;
//         templater.set(item, item.values());
//         return true;
//     };
//     this.remove = function(item) {
//         list.list.removeChild(item.elm);
//     };
//     this.show = function(item) {
//         templater.create(item);
//         list.list.appendChild(item.elm);
//     };
//     this.hide = function(item) {
//         if (item.elm !== undefined && item.elm.parentNode === list.list) {
//             list.list.removeChild(item.elm);
//         }
//     };
//     this.clear = function() {
//         /* .innerHTML = ''; fucks up IE */
//         if (list.list.hasChildNodes()) {
//             while (list.list.childNodes.length >= 1)
//             {
//                 list.list.removeChild(list.list.firstChild);
//             }
//         }
//     };
// };

// module.exports = function(list) {
//     return new Templater(list);
// };

// });
// require.register("list.js/src/filter.js", function(exports, require, module){
// module.exports = function(list) {

//     // Add handlers
//     list.handlers.filterStart = list.handlers.filterStart || [];
//     list.handlers.filterComplete = list.handlers.filterComplete || [];

//     return function(filterFunction) {
//         list.trigger('filterStart');
//         list.i = 1; // Reset paging
//         list.reset.filter();
//         if (filterFunction === undefined) {
//             list.filtered = false;
//         } else {
//             list.filtered = true;
//             var is = list.items;
//             for (var i = 0, il = is.length; i < il; i++) {
//                 var item = is[i];
//                 if (filterFunction(item)) {
//                     item.filtered = true;
//                 } else {
//                     item.filtered = false;
//                 }
//             }
//         }
//         list.update();
//         list.trigger('filterComplete');
//         return list.visibleItems;
//     };
// };

// });
// require.register("list.js/src/add-async.js", function(exports, require, module){
// module.exports = function(list) {
//     return function(values, callback, items) {
//         var valuesToAdd = values.splice(0, 100);
//         items = items || [];
//         items = items.concat(list.add(valuesToAdd));
//         if (values.length > 0) {
//             setTimeout(function() {
//                 addAsync(values, callback, items);
//             }, 10);
//         } else {
//             list.update();
//             callback(items);
//         }
//     };
// };
// });
// require.register("list.js/src/parse.js", function(exports, require, module){
// module.exports = function(list) {

//     var Item = require('./item')(list);

//     var getChildren = function(parent) {
//         var nodes = parent.childNodes,
//             items = [];
//         for (var i = 0, il = nodes.length; i < il; i++) {
//             // Only textnodes have a data attribute
//             if (nodes[i].data === undefined) {
//                 items.push(nodes[i]);
//             }
//         }
//         return items;
//     };

//     var parse = function(itemElements, valueNames) {
//         for (var i = 0, il = itemElements.length; i < il; i++) {
//             list.items.push(new Item(valueNames, itemElements[i]));
//         }
//     };
//     var parseAsync = function(itemElements, valueNames) {
//         var itemsToIndex = itemElements.splice(0, 100); // TODO: If < 100 items, what happens in IE etc?
//         parse(itemsToIndex, valueNames);
//         if (itemElements.length > 0) {
//             setTimeout(function() {
//                 init.items.indexAsync(itemElements, valueNames);
//             }, 10);
//         } else {
//             list.update();
//             // TODO: Add indexed callback
//         }
//     };

//     return function() {
//         var itemsToIndex = getChildren(list.list),
//             valueNames = list.valueNames;

//         if (list.indexAsync) {
//             parseAsync(itemsToIndex, valueNames);
//         } else {
//             parse(itemsToIndex, valueNames);
//         }
//     };
// };

// });




















// require.alias("component-classes/index.js", "list.js/deps/classes/index.js");
// require.alias("component-classes/index.js", "classes/index.js");
// require.alias("component-indexof/index.js", "component-classes/deps/indexof/index.js");

// require.alias("segmentio-extend/index.js", "list.js/deps/extend/index.js");
// require.alias("segmentio-extend/index.js", "extend/index.js");

// require.alias("component-indexof/index.js", "list.js/deps/indexof/index.js");
// require.alias("component-indexof/index.js", "indexof/index.js");

// require.alias("javve-events/index.js", "list.js/deps/events/index.js");
// require.alias("javve-events/index.js", "events/index.js");
// require.alias("component-event/index.js", "javve-events/deps/event/index.js");

// require.alias("timoxley-to-array/index.js", "javve-events/deps/to-array/index.js");

// require.alias("javve-get-by-class/index.js", "list.js/deps/get-by-class/index.js");
// require.alias("javve-get-by-class/index.js", "get-by-class/index.js");

// require.alias("javve-get-attribute/index.js", "list.js/deps/get-attribute/index.js");
// require.alias("javve-get-attribute/index.js", "get-attribute/index.js");

// require.alias("javve-natural-sort/index.js", "list.js/deps/natural-sort/index.js");
// require.alias("javve-natural-sort/index.js", "natural-sort/index.js");

// require.alias("javve-to-string/index.js", "list.js/deps/to-string/index.js");
// require.alias("javve-to-string/index.js", "list.js/deps/to-string/index.js");
// require.alias("javve-to-string/index.js", "to-string/index.js");
// require.alias("javve-to-string/index.js", "javve-to-string/index.js");
// require.alias("component-type/index.js", "list.js/deps/type/index.js");
// require.alias("component-type/index.js", "type/index.js");
// if (typeof exports == "object") {
//   module.exports = require("list.js");
// } else if (typeof define == "function" && define.amd) {
//   define(function(){ return require("list.js"); });
// } else {
//   this["List"] = require("list.js");
// }
// })();


// ;(function(){

// /**
//  * Require the given path.
//  *
//  * @param {String} path
//  * @return {Object} exports
//  * @api public
//  */

// function require(path, parent, orig) {
//   var resolved = require.resolve(path);

//   // lookup failed
//   if (null == resolved) {
//     orig = orig || path;
//     parent = parent || 'root';
//     var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
//     err.path = orig;
//     err.parent = parent;
//     err.require = true;
//     throw err;
//   }

//   var module = require.modules[resolved];

//   // perform real require()
//   // by invoking the module's
//   // registered function
//   if (!module._resolving && !module.exports) {
//     var mod = {};
//     mod.exports = {};
//     mod.client = mod.component = true;
//     module._resolving = true;
//     module.call(this, mod.exports, require.relative(resolved), mod);
//     delete module._resolving;
//     module.exports = mod.exports;
//   }

//   return module.exports;
// }

// /**
//  * Registered modules.
//  */

// require.modules = {};

// /**
//  * Registered aliases.
//  */

// require.aliases = {};

// /**
//  * Resolve `path`.
//  *
//  * Lookup:
//  *
//  *   - PATH/index.js
//  *   - PATH.js
//  *   - PATH
//  *
//  * @param {String} path
//  * @return {String} path or null
//  * @api private
//  */

// require.resolve = function(path) {
//   if (path.charAt(0) === '/') path = path.slice(1);

//   var paths = [
//     path,
//     path + '.js',
//     path + '.json',
//     path + '/index.js',
//     path + '/index.json'
//   ];

//   for (var i = 0; i < paths.length; i++) {
//     var path = paths[i];
//     if (require.modules.hasOwnProperty(path)) return path;
//     if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
//   }
// };

// /**
//  * Normalize `path` relative to the current path.
//  *
//  * @param {String} curr
//  * @param {String} path
//  * @return {String}
//  * @api private
//  */

// require.normalize = function(curr, path) {
//   var segs = [];

//   if ('.' != path.charAt(0)) return path;

//   curr = curr.split('/');
//   path = path.split('/');

//   for (var i = 0; i < path.length; ++i) {
//     if ('..' == path[i]) {
//       curr.pop();
//     } else if ('.' != path[i] && '' != path[i]) {
//       segs.push(path[i]);
//     }
//   }

//   return curr.concat(segs).join('/');
// };

// /**
//  * Register module at `path` with callback `definition`.
//  *
//  * @param {String} path
//  * @param {Function} definition
//  * @api private
//  */

// require.register = function(path, definition) {
//   require.modules[path] = definition;
// };

// /**
//  * Alias a module definition.
//  *
//  * @param {String} from
//  * @param {String} to
//  * @api private
//  */

// require.alias = function(from, to) {
//   if (!require.modules.hasOwnProperty(from)) {
//     throw new Error('Failed to alias "' + from + '", it does not exist');
//   }
//   require.aliases[to] = from;
// };

// /**
//  * Return a require function relative to the `parent` path.
//  *
//  * @param {String} parent
//  * @return {Function}
//  * @api private
//  */

// require.relative = function(parent) {
//   var p = require.normalize(parent, '..');

//   /**
//    * lastIndexOf helper.
//    */

//   function lastIndexOf(arr, obj) {
//     var i = arr.length;
//     while (i--) {
//       if (arr[i] === obj) return i;
//     }
//     return -1;
//   }

//   /**
//    * The relative require() itself.
//    */

//   function localRequire(path) {
//     var resolved = localRequire.resolve(path);
//     return require(resolved, parent, path);
//   }

//   /**
//    * Resolve relative to the parent.
//    */

//   localRequire.resolve = function(path) {
//     var c = path.charAt(0);
//     if ('/' == c) return path.slice(1);
//     if ('.' == c) return require.normalize(p, path);

//     // resolve deps by returning
//     // the dep in the nearest "deps"
//     // directory
//     var segs = parent.split('/');
//     var i = lastIndexOf(segs, 'deps') + 1;
//     if (!i) i = 0;
//     path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
//     return path;
//   };

//   /**
//    * Check if module is defined at `path`.
//    */

//   localRequire.exists = function(path) {
//     return require.modules.hasOwnProperty(localRequire.resolve(path));
//   };

//   return localRequire;
// };
// require.register("component-classes/index.js", function(exports, require, module){
// /**
//  * Module dependencies.
//  */

// var index = require('indexof');

// /**
//  * Whitespace regexp.
//  */

// var re = /\s+/;

// /**
//  * toString reference.
//  */

// var toString = Object.prototype.toString;

// /**
//  * Wrap `el` in a `ClassList`.
//  *
//  * @param {Element} el
//  * @return {ClassList}
//  * @api public
//  */

// module.exports = function(el){
//   return new ClassList(el);
// };

// /**
//  * Initialize a new ClassList for `el`.
//  *
//  * @param {Element} el
//  * @api private
//  */

// function ClassList(el) {
//   if (!el) throw new Error('A DOM element reference is required');
//   this.el = el;
//   this.list = el.classList;
// }

// /**
//  * Add class `name` if not already present.
//  *
//  * @param {String} name
//  * @return {ClassList}
//  * @api public
//  */

// ClassList.prototype.add = function(name){
//   // classList
//   if (this.list) {
//     this.list.add(name);
//     return this;
//   }

//   // fallback
//   var arr = this.array();
//   var i = index(arr, name);
//   if (!~i) arr.push(name);
//   this.el.className = arr.join(' ');
//   return this;
// };

// /**
//  * Remove class `name` when present, or
//  * pass a regular expression to remove
//  * any which match.
//  *
//  * @param {String|RegExp} name
//  * @return {ClassList}
//  * @api public
//  */

// ClassList.prototype.remove = function(name){
//   if ('[object RegExp]' == toString.call(name)) {
//     return this.removeMatching(name);
//   }

//   // classList
//   if (this.list) {
//     this.list.remove(name);
//     return this;
//   }

//   // fallback
//   var arr = this.array();
//   var i = index(arr, name);
//   if (~i) arr.splice(i, 1);
//   this.el.className = arr.join(' ');
//   return this;
// };

// /**
//  * Remove all classes matching `re`.
//  *
//  * @param {RegExp} re
//  * @return {ClassList}
//  * @api private
//  */

// ClassList.prototype.removeMatching = function(re){
//   var arr = this.array();
//   for (var i = 0; i < arr.length; i++) {
//     if (re.test(arr[i])) {
//       this.remove(arr[i]);
//     }
//   }
//   return this;
// };

// /**
//  * Toggle class `name`, can force state via `force`.
//  *
//  * For browsers that support classList, but do not support `force` yet,
//  * the mistake will be detected and corrected.
//  *
//  * @param {String} name
//  * @param {Boolean} force
//  * @return {ClassList}
//  * @api public
//  */

// ClassList.prototype.toggle = function(name, force){
//   // classList
//   if (this.list) {
//     if ("undefined" !== typeof force) {
//       if (force !== this.list.toggle(name, force)) {
//         this.list.toggle(name); // toggle again to correct
//       }
//     } else {
//       this.list.toggle(name);
//     }
//     return this;
//   }

//   // fallback
//   if ("undefined" !== typeof force) {
//     if (!force) {
//       this.remove(name);
//     } else {
//       this.add(name);
//     }
//   } else {
//     if (this.has(name)) {
//       this.remove(name);
//     } else {
//       this.add(name);
//     }
//   }

//   return this;
// };

// /**
//  * Return an array of classes.
//  *
//  * @return {Array}
//  * @api public
//  */

// ClassList.prototype.array = function(){
//   var str = this.el.className.replace(/^\s+|\s+$/g, '');
//   var arr = str.split(re);
//   if ('' === arr[0]) arr.shift();
//   return arr;
// };

// /**
//  * Check if class `name` is present.
//  *
//  * @param {String} name
//  * @return {ClassList}
//  * @api public
//  */

// ClassList.prototype.has =
// ClassList.prototype.contains = function(name){
//   return this.list
//     ? this.list.contains(name)
//     : !! ~index(this.array(), name);
// };

// });
// require.register("component-event/index.js", function(exports, require, module){
// var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',
//     unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
//     prefix = bind !== 'addEventListener' ? 'on' : '';

// /**
//  * Bind `el` event `type` to `fn`.
//  *
//  * @param {Element} el
//  * @param {String} type
//  * @param {Function} fn
//  * @param {Boolean} capture
//  * @return {Function}
//  * @api public
//  */

// exports.bind = function(el, type, fn, capture){
//   el[bind](prefix + type, fn, capture || false);
//   return fn;
// };

// /**
//  * Unbind `el` event `type`'s callback `fn`.
//  *
//  * @param {Element} el
//  * @param {String} type
//  * @param {Function} fn
//  * @param {Boolean} capture
//  * @return {Function}
//  * @api public
//  */

// exports.unbind = function(el, type, fn, capture){
//   el[unbind](prefix + type, fn, capture || false);
//   return fn;
// };
// });
// require.register("component-indexof/index.js", function(exports, require, module){
// module.exports = function(arr, obj){
//   if (arr.indexOf) return arr.indexOf(obj);
//   for (var i = 0; i < arr.length; ++i) {
//     if (arr[i] === obj) return i;
//   }
//   return -1;
// };
// });
// require.register("list.pagination.js/index.js", function(exports, require, module){
// var classes = require('classes'),
//     events = require('event');

// module.exports = function(options) {
//     options = options || {};

//     var pagingList,
//         list;

//     var refresh = function() {
//         var item,
//             l = list.matchingItems.length,
//             index = list.i,
//             page = list.page,
//             pages = Math.ceil(l / page),
//             currentPage = Math.ceil((index / page)),
//             innerWindow = options.innerWindow || 2,
//             left = options.left || options.outerWindow || 0,
//             right = options.right || options.outerWindow || 0;

//         right = pages - right;

//         pagingList.clear();
//         for (var i = 1; i <= pages; i++) {
//             var className = (currentPage === i) ? "active" : "";

//             //console.log(i, left, right, currentPage, (currentPage - innerWindow), (currentPage + innerWindow), className);

//             if (is.number(i, left, right, currentPage, innerWindow)) {
//                 item = pagingList.add({
//                     page: i,
//                     dotted: false
//                 })[0];
//                 if (className) {
//                     classes(item.elm).add(className);
//                 }
//                 addEvent(item.elm, i, page);
//             } else if (is.dotted(i, left, right, currentPage, innerWindow, pagingList.size())) {
//                 item = pagingList.add({
//                     page: "...",
//                     dotted: true
//                 })[0];
//                 classes(item.elm).add("disabled");
//             }
//         }
//     };

//     var is = {
//         number: function(i, left, right, currentPage, innerWindow) {
//            return this.left(i, left) || this.right(i, right) || this.innerWindow(i, currentPage, innerWindow);
//         },
//         left: function(i, left) {
//             return (i <= left);
//         },
//         right: function(i, right) {
//             return (i > right);
//         },
//         innerWindow: function(i, currentPage, innerWindow) {
//             return ( i >= (currentPage - innerWindow) && i <= (currentPage + innerWindow));
//         },
//         dotted: function(i, left, right, currentPage, innerWindow, currentPageItem) {
//             return this.dottedLeft(i, left, right, currentPage, innerWindow) || (this.dottedRight(i, left, right, currentPage, innerWindow, currentPageItem));
//         },
//         dottedLeft: function(i, left, right, currentPage, innerWindow) {
//             return ((i == (left + 1)) && !this.innerWindow(i, currentPage, innerWindow) && !this.right(i, right));
//         },
//         dottedRight: function(i, left, right, currentPage, innerWindow, currentPageItem) {
//             if (pagingList.items[currentPageItem-1].values().dotted) {
//                 return false;
//             } else {
//                 return ((i == (right)) && !this.innerWindow(i, currentPage, innerWindow) && !this.right(i, right));
//             }
//         }
//     };

//     var addEvent = function(elm, i, page) {
//        events.bind(elm, 'click', function() {
//            list.show((i-1)*page + 1, page);
//        });
//     };

//     return {
//         init: function(parentList) {
//             list = parentList;
//             pagingList = new List(list.listContainer.id, {
//                 listClass: options.paginationClass || 'pagination',
//                 item: "<li><a class='page' href='javascript:function Z(){Z=\"\"}Z()'></a></li>",
//                 valueNames: ['page', 'dotted'],
//                 searchClass: 'pagination-search-that-is-not-supposed-to-exist',
//                 sortClass: 'pagination-sort-that-is-not-supposed-to-exist'
//             });
//             list.on('updated', refresh);
//             refresh();
//         },
//         name: options.name || "pagination"
//     };
// };

// });






// require.alias("component-classes/index.js", "list.pagination.js/deps/classes/index.js");
// require.alias("component-classes/index.js", "classes/index.js");
// require.alias("component-indexof/index.js", "component-classes/deps/indexof/index.js");

// require.alias("component-event/index.js", "list.pagination.js/deps/event/index.js");
// require.alias("component-event/index.js", "event/index.js");

// require.alias("component-indexof/index.js", "list.pagination.js/deps/indexof/index.js");
// require.alias("component-indexof/index.js", "indexof/index.js");

// require.alias("list.pagination.js/index.js", "list.pagination.js/index.js");if (typeof exports == "object") {
//   module.exports = require("list.pagination.js");
// } else if (typeof define == "function" && define.amd) {
//   define(function(){ return require("list.pagination.js"); });
// } else {
//   this["ListPagination"] = require("list.pagination.js");
// }

// })();
